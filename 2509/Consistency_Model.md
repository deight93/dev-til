
# 일관성 모델 (Linearizability / Sequential / Causal / Eventual)

일관성 모델: 분산 시스템에서 **읽기/쓰기의 관찰 규칙**을 정의하는 계약

## 왜 중요한가

* **UX·정확성·지연**의 트레이드오프를 수치로 결정하고 문서화할 수 있습니다.
* API/캐시/복제/라우팅 전 구간에서 **어떤 값을 언제 보여줄지**를 일관되게 보장합니다.
* 멀티리전·팔로워 리드·리더리스 환경에서 **논쟁(“틀렸다 vs 느리다”)을 끝내는 기준**이 됩니다.

## 핵심 개념/정의

| 모델                         | 직관                                 | 보장           | 비용/지연 감각     | 전형적 구현        |
| -------------------------- | ---------------------------------- | ------------ | ------------ | ------------- |
| **Linearizability(선형화)**   | 실시간(real-time) 순서까지 보존             | 가장 강함        | 합의·동기복제로 지연↑ | 리더 합의/전역 타임라인 |
| **Sequential Consistency** | 각 클라이언트 **프로그램 순서**만 보존(실시간 제약 없음) | 강함(선형화보다 약함) | 중간           | 단일 로그/리더 순서   |
| **Causal Consistency**     | **인과(a→b)** 순서만 전역 동일              | 중간           | 낮음\~중간       | VC/HLC, 지연 전파 |
| **Eventual Consistency**   | 시간이 지나면 **수렴**만 보장                 | 약함           | 지연↓·가용성↑     | 가십/안티엔트로피     |

* **선형화**: 비겹치는 연산은 **실시간 순서 그대로**. 한 복제본처럼 보입니다.
* **Sequential**: 시간 역행처럼 보일 수 있으나 **프로그램 순서**는 유지됩니다.
* **Causal**: 인과만 보존(독립 연산 순서는 달라도 무방).
* **Eventual**: 중간엔 제각각이어도 **결국 수렴**합니다.


## 세션 보장(사용자 체감 보강)

* Read-your-writes(RYW): 내가 방금 쓴 값은 내가 읽을 때 반드시 보입니다.
* Monotonic Reads(MR): 같은 키를 계속 읽으면 시간이 거꾸로 가지지 않습니다.
* Monotonic Writes(MW): 내가 쓴 쓰기의 순서가 보존됩니다.
* Writes-follow-Reads(WFR): 어떤 값을 읽고 그에 의존한 쓰기는 그 읽기 이후로 보입니다.
→ Causal Consistency는 위 4종을 자연스럽게 내포합니다. Eventual에서도 세션 토큰으로 보강 가능합니다.


## 요약

* **선형화**는 가장 강하지만 지연↑, **Causal+세션 보장**이 실무의 균형점, **Eventual**은 수렴 규칙이 생명입니다.
* Linearizability는 가장 직관적이지만 지연 비용이 큽니다.
* Causal+세션 보장은 UX 품질과 성능의 균형점입니다.
실전은 핵심 경로=강C, 조회 경로=약C(+세션 토큰) 의 혼합 설계가 정답에 가깝습니다.